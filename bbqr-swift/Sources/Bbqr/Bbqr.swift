// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(bbqrffiFFI)
    import bbqrffiFFI
#endif

private extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len: 0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_bbqrffi_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_bbqrffi_rustbuffer_free(self, $0) }
    }
}

private extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

private extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

private func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
private func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset ..< reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value) { reader.data.copyBytes(to: $0, from: range) }
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
private func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> [UInt8] {
    let range = reader.offset ..< (reader.offset + count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer { buffer in
        reader.data.copyBytes(to: buffer, from: range)
    }
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
private func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return try Float(bitPattern: readInt(&reader))
}

// Reads a float at the current offset.
private func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return try Double(bitPattern: readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
private func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

private func createWriter() -> [UInt8] {
    return []
}

private func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
private func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

private func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

private func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
private protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
private protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType {}

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
private protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
        var writer = createWriter()
        write(value, into: &writer)
        return RustBuffer(bytes: writer)
    }
}

// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
private enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

private extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        lock()
        defer { self.unlock() }
        return try f()
    }
}

private let CALL_SUCCESS: Int8 = 0
private let CALL_ERROR: Int8 = 1
private let CALL_UNEXPECTED_ERROR: Int8 = 2
private let CALL_CANCELLED: Int8 = 3

private extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T
) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
    case CALL_SUCCESS:
        return

    case CALL_ERROR:
        if let errorHandler = errorHandler {
            throw try errorHandler(callStatus.errorBuf)
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.unexpectedRustCallError
        }

    case CALL_UNEXPECTED_ERROR:
        // When the rust code sees a panic, it tries to construct a RustBuffer
        // with the message.  But if that code panics, then it just sends back
        // an empty buffer.
        if callStatus.errorBuf.len > 0 {
            throw try UniffiInternalError.rustPanic(FfiConverterString.lift(callStatus.errorBuf))
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.rustPanic("Rust panic")
        }

    case CALL_CANCELLED:
        fatalError("Cancellation not supported yet")

    default:
        throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> Void
) {
    do {
        try writeReturn(makeCall())
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> Void,
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

    func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        map.count
    }
}

// Public interface members begin here.

private struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return try String(bytes: readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

private struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return try Data(readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}

public protocol ContinuousJoinerProtocol: AnyObject {
    func addPart(part: String) throws -> ContinuousJoinResult
}

open class ContinuousJoiner:
    ContinuousJoinerProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bbqrffi_fn_clone_continuousjoiner(self.pointer, $0) }
    }

    public convenience init() {
        let pointer =
            try! rustCall {
                uniffi_bbqrffi_fn_constructor_continuousjoiner_new($0
                )
            }
        self.init(unsafeFromRawPointer: pointer)
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bbqrffi_fn_free_continuousjoiner(pointer, $0) }
    }

    open func addPart(part: String) throws -> ContinuousJoinResult {
        return try FfiConverterTypeContinuousJoinResult.lift(rustCallWithError(FfiConverterTypeContinuousJoinError.lift) {
            uniffi_bbqrffi_fn_method_continuousjoiner_add_part(self.uniffiClonePointer(),
                                                               FfiConverterString.lower(part), $0)
        })
    }
}

public struct FfiConverterTypeContinuousJoiner: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ContinuousJoiner

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ContinuousJoiner {
        return ContinuousJoiner(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ContinuousJoiner) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ContinuousJoiner {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ContinuousJoiner, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeContinuousJoiner_lift(_ pointer: UnsafeMutableRawPointer) throws -> ContinuousJoiner {
    return try FfiConverterTypeContinuousJoiner.lift(pointer)
}

public func FfiConverterTypeContinuousJoiner_lower(_ value: ContinuousJoiner) -> UnsafeMutableRawPointer {
    return FfiConverterTypeContinuousJoiner.lower(value)
}

public protocol JoinedProtocol: AnyObject {
    func data() -> Data

    func encoding() -> Encoding

    func fileType() -> FileType
}

open class Joined:
    JoinedProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bbqrffi_fn_clone_joined(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bbqrffi_fn_free_joined(pointer, $0) }
    }

    public static func tryFromParts(parts: [String]) throws -> Joined {
        return try FfiConverterTypeJoined.lift(rustCallWithError(FfiConverterTypeJoinError.lift) {
            uniffi_bbqrffi_fn_constructor_joined_try_from_parts(
                FfiConverterSequenceString.lower(parts), $0
            )
        })
    }

    open func data() -> Data {
        return try! FfiConverterData.lift(try! rustCall {
            uniffi_bbqrffi_fn_method_joined_data(self.uniffiClonePointer(), $0)
        })
    }

    open func encoding() -> Encoding {
        return try! FfiConverterTypeEncoding.lift(try! rustCall {
            uniffi_bbqrffi_fn_method_joined_encoding(self.uniffiClonePointer(), $0)
        })
    }

    open func fileType() -> FileType {
        return try! FfiConverterTypeFileType.lift(try! rustCall {
            uniffi_bbqrffi_fn_method_joined_file_type(self.uniffiClonePointer(), $0)
        })
    }
}

public struct FfiConverterTypeJoined: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Joined

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Joined {
        return Joined(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Joined) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Joined {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Joined, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeJoined_lift(_ pointer: UnsafeMutableRawPointer) throws -> Joined {
    return try FfiConverterTypeJoined.lift(pointer)
}

public func FfiConverterTypeJoined_lower(_ value: Joined) -> UnsafeMutableRawPointer {
    return FfiConverterTypeJoined.lower(value)
}

public protocol SplitProtocol: AnyObject {
    func encoding() -> Encoding

    func parts() -> [String]

    func version() -> Version
}

open class Split:
    SplitProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bbqrffi_fn_clone_split(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bbqrffi_fn_free_split(pointer, $0) }
    }

    public static func tryFromData(bytes: Data, fileType: FileType, options: SplitOptions) throws -> Split {
        return try FfiConverterTypeSplit.lift(rustCallWithError(FfiConverterTypeSplitError.lift) {
            uniffi_bbqrffi_fn_constructor_split_try_from_data(
                FfiConverterData.lower(bytes),
                FfiConverterTypeFileType.lower(fileType),
                FfiConverterTypeSplitOptions.lower(options), $0
            )
        })
    }

    open func encoding() -> Encoding {
        return try! FfiConverterTypeEncoding.lift(try! rustCall {
            uniffi_bbqrffi_fn_method_split_encoding(self.uniffiClonePointer(), $0)
        })
    }

    open func parts() -> [String] {
        return try! FfiConverterSequenceString.lift(try! rustCall {
            uniffi_bbqrffi_fn_method_split_parts(self.uniffiClonePointer(), $0)
        })
    }

    open func version() -> Version {
        return try! FfiConverterTypeVersion.lift(try! rustCall {
            uniffi_bbqrffi_fn_method_split_version(self.uniffiClonePointer(), $0)
        })
    }
}

public struct FfiConverterTypeSplit: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Split

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Split {
        return Split(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Split) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Split {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Split, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeSplit_lift(_ pointer: UnsafeMutableRawPointer) throws -> Split {
    return try FfiConverterTypeSplit.lift(pointer)
}

public func FfiConverterTypeSplit_lower(_ value: Split) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSplit.lower(value)
}

public struct SplitOptions {
    public var encoding: Encoding
    public var minSplitNumber: UInt16
    public var maxSplitNumber: UInt16
    public var minVersion: Version
    public var maxVersion: Version

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(encoding: Encoding, minSplitNumber: UInt16, maxSplitNumber: UInt16, minVersion: Version, maxVersion: Version) {
        self.encoding = encoding
        self.minSplitNumber = minSplitNumber
        self.maxSplitNumber = maxSplitNumber
        self.minVersion = minVersion
        self.maxVersion = maxVersion
    }
}

extension SplitOptions: Equatable, Hashable {
    public static func == (lhs: SplitOptions, rhs: SplitOptions) -> Bool {
        if lhs.encoding != rhs.encoding {
            return false
        }
        if lhs.minSplitNumber != rhs.minSplitNumber {
            return false
        }
        if lhs.maxSplitNumber != rhs.maxSplitNumber {
            return false
        }
        if lhs.minVersion != rhs.minVersion {
            return false
        }
        if lhs.maxVersion != rhs.maxVersion {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(encoding)
        hasher.combine(minSplitNumber)
        hasher.combine(maxSplitNumber)
        hasher.combine(minVersion)
        hasher.combine(maxVersion)
    }
}

public struct FfiConverterTypeSplitOptions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SplitOptions {
        return
            try SplitOptions(
                encoding: FfiConverterTypeEncoding.read(from: &buf),
                minSplitNumber: FfiConverterUInt16.read(from: &buf),
                maxSplitNumber: FfiConverterUInt16.read(from: &buf),
                minVersion: FfiConverterTypeVersion.read(from: &buf),
                maxVersion: FfiConverterTypeVersion.read(from: &buf)
            )
    }

    public static func write(_ value: SplitOptions, into buf: inout [UInt8]) {
        FfiConverterTypeEncoding.write(value.encoding, into: &buf)
        FfiConverterUInt16.write(value.minSplitNumber, into: &buf)
        FfiConverterUInt16.write(value.maxSplitNumber, into: &buf)
        FfiConverterTypeVersion.write(value.minVersion, into: &buf)
        FfiConverterTypeVersion.write(value.maxVersion, into: &buf)
    }
}

public func FfiConverterTypeSplitOptions_lift(_ buf: RustBuffer) throws -> SplitOptions {
    return try FfiConverterTypeSplitOptions.lift(buf)
}

public func FfiConverterTypeSplitOptions_lower(_ value: SplitOptions) -> RustBuffer {
    return FfiConverterTypeSplitOptions.lower(value)
}

public enum ContinuousJoinError {
    case HeaderParseError(error: HeaderParseError
    )
    case JoinError(error: JoinError
    )
    case DecodeError(error: DecodeError
    )
}

public struct FfiConverterTypeContinuousJoinError: FfiConverterRustBuffer {
    typealias SwiftType = ContinuousJoinError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ContinuousJoinError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .HeaderParseError(
                error: FfiConverterTypeHeaderParseError.read(from: &buf)
            )
        case 2: return try .JoinError(
                error: FfiConverterTypeJoinError.read(from: &buf)
            )
        case 3: return try .DecodeError(
                error: FfiConverterTypeDecodeError.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ContinuousJoinError, into buf: inout [UInt8]) {
        switch value {
        case let .HeaderParseError(error):
            writeInt(&buf, Int32(1))
            FfiConverterTypeHeaderParseError.write(error, into: &buf)

        case let .JoinError(error):
            writeInt(&buf, Int32(2))
            FfiConverterTypeJoinError.write(error, into: &buf)

        case let .DecodeError(error):
            writeInt(&buf, Int32(3))
            FfiConverterTypeDecodeError.write(error, into: &buf)
        }
    }
}

extension ContinuousJoinError: Equatable, Hashable {}

extension ContinuousJoinError: Error {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ContinuousJoinResult {
    case notStarted
    case inProgress(partsLeft: UInt16
    )
    case complete(Joined
    )
}

public struct FfiConverterTypeContinuousJoinResult: FfiConverterRustBuffer {
    typealias SwiftType = ContinuousJoinResult

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ContinuousJoinResult {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .notStarted

        case 2: return try .inProgress(partsLeft: FfiConverterUInt16.read(from: &buf)
            )

        case 3: return try .complete(FfiConverterTypeJoined.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ContinuousJoinResult, into buf: inout [UInt8]) {
        switch value {
        case .notStarted:
            writeInt(&buf, Int32(1))

        case let .inProgress(partsLeft):
            writeInt(&buf, Int32(2))
            FfiConverterUInt16.write(partsLeft, into: &buf)

        case let .complete(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeJoined.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeContinuousJoinResult_lift(_ buf: RustBuffer) throws -> ContinuousJoinResult {
    return try FfiConverterTypeContinuousJoinResult.lift(buf)
}

public func FfiConverterTypeContinuousJoinResult_lower(_ value: ContinuousJoinResult) -> RustBuffer {
    return FfiConverterTypeContinuousJoinResult.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DecodeError {
    case unableToDecodeHex(UInt16, String)
    case unableToDecodeBase32(UInt16, String)
    case unableToInflateZlib(String
    )
}

public struct FfiConverterTypeDecodeError: FfiConverterRustBuffer {
    typealias SwiftType = DecodeError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DecodeError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .unableToDecodeHex(FfiConverterUInt16.read(from: &buf), FfiConverterString.read(from: &buf))

        case 2: return try .unableToDecodeBase32(FfiConverterUInt16.read(from: &buf), FfiConverterString.read(from: &buf))

        case 3: return try .unableToInflateZlib(FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DecodeError, into buf: inout [UInt8]) {
        switch value {
        case let .unableToDecodeHex(v1, v2):
            writeInt(&buf, Int32(1))
            FfiConverterUInt16.write(v1, into: &buf)
            FfiConverterString.write(v2, into: &buf)

        case let .unableToDecodeBase32(v1, v2):
            writeInt(&buf, Int32(2))
            FfiConverterUInt16.write(v1, into: &buf)
            FfiConverterString.write(v2, into: &buf)

        case let .unableToInflateZlib(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeDecodeError_lift(_ buf: RustBuffer) throws -> DecodeError {
    return try FfiConverterTypeDecodeError.lift(buf)
}

public func FfiConverterTypeDecodeError_lower(_ value: DecodeError) -> RustBuffer {
    return FfiConverterTypeDecodeError.lower(value)
}

extension DecodeError: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Errors that can occur when encoding data
 */

public enum EncodeError {
    case empty
    case compressionError(error: String
    )
}

public struct FfiConverterTypeEncodeError: FfiConverterRustBuffer {
    typealias SwiftType = EncodeError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EncodeError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .empty

        case 2: return try .compressionError(error: FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EncodeError, into buf: inout [UInt8]) {
        switch value {
        case .empty:
            writeInt(&buf, Int32(1))

        case let .compressionError(error):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(error, into: &buf)
        }
    }
}

public func FfiConverterTypeEncodeError_lift(_ buf: RustBuffer) throws -> EncodeError {
    return try FfiConverterTypeEncodeError.lift(buf)
}

public func FfiConverterTypeEncodeError_lower(_ value: EncodeError) -> RustBuffer {
    return FfiConverterTypeEncodeError.lower(value)
}

extension EncodeError: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Encoding {
    case hex
    case base32
    case zlib
}

public struct FfiConverterTypeEncoding: FfiConverterRustBuffer {
    typealias SwiftType = Encoding

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Encoding {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .hex

        case 2: return .base32

        case 3: return .zlib

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Encoding, into buf: inout [UInt8]) {
        switch value {
        case .hex:
            writeInt(&buf, Int32(1))

        case .base32:
            writeInt(&buf, Int32(2))

        case .zlib:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeEncoding_lift(_ buf: RustBuffer) throws -> Encoding {
    return try FfiConverterTypeEncoding.lift(buf)
}

public func FfiConverterTypeEncoding_lower(_ value: Encoding) -> RustBuffer {
    return FfiConverterTypeEncoding.lower(value)
}

extension Encoding: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FileType {
    case psbt
    case transaction
    case json
    case cbor
    case unicodeText
}

public struct FfiConverterTypeFileType: FfiConverterRustBuffer {
    typealias SwiftType = FileType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FileType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .psbt

        case 2: return .transaction

        case 3: return .json

        case 4: return .cbor

        case 5: return .unicodeText

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FileType, into buf: inout [UInt8]) {
        switch value {
        case .psbt:
            writeInt(&buf, Int32(1))

        case .transaction:
            writeInt(&buf, Int32(2))

        case .json:
            writeInt(&buf, Int32(3))

        case .cbor:
            writeInt(&buf, Int32(4))

        case .unicodeText:
            writeInt(&buf, Int32(5))
        }
    }
}

public func FfiConverterTypeFileType_lift(_ buf: RustBuffer) throws -> FileType {
    return try FfiConverterTypeFileType.lift(buf)
}

public func FfiConverterTypeFileType_lower(_ value: FileType) -> RustBuffer {
    return FfiConverterTypeFileType.lower(value)
}

extension FileType: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum HeaderParseError {
    case empty
    case invalidEncoding(String
    )
    case invalidFileType(String
    )
    case invalidFixedHeader
    case invalidHeaderSize(UInt16
    )
    case invalidHeaderParts(String
    )
}

public struct FfiConverterTypeHeaderParseError: FfiConverterRustBuffer {
    typealias SwiftType = HeaderParseError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HeaderParseError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .empty

        case 2: return try .invalidEncoding(FfiConverterString.read(from: &buf)
            )

        case 3: return try .invalidFileType(FfiConverterString.read(from: &buf)
            )

        case 4: return .invalidFixedHeader

        case 5: return try .invalidHeaderSize(FfiConverterUInt16.read(from: &buf)
            )

        case 6: return try .invalidHeaderParts(FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HeaderParseError, into buf: inout [UInt8]) {
        switch value {
        case .empty:
            writeInt(&buf, Int32(1))

        case let .invalidEncoding(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)

        case let .invalidFileType(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)

        case .invalidFixedHeader:
            writeInt(&buf, Int32(4))

        case let .invalidHeaderSize(v1):
            writeInt(&buf, Int32(5))
            FfiConverterUInt16.write(v1, into: &buf)

        case let .invalidHeaderParts(v1):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeHeaderParseError_lift(_ buf: RustBuffer) throws -> HeaderParseError {
    return try FfiConverterTypeHeaderParseError.lift(buf)
}

public func FfiConverterTypeHeaderParseError_lower(_ value: HeaderParseError) -> RustBuffer {
    return FfiConverterTypeHeaderParseError.lower(value)
}

extension HeaderParseError: Equatable, Hashable {}

public enum JoinError {
    case Empty
    case ConflictingHeaders
    case TooManyParts(expected: UInt16, got: UInt16)
    case DuplicatePartWrongContent(index: UInt16
    )
    case PartWithNoData(index: UInt16
    )
    case MissingPart(index: UInt16
    )
    case HeaderParseError(error: HeaderParseError
    )
    case DecodeError(error: DecodeError
    )
}

public struct FfiConverterTypeJoinError: FfiConverterRustBuffer {
    typealias SwiftType = JoinError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> JoinError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .Empty
        case 2: return .ConflictingHeaders
        case 3: return try .TooManyParts(
                expected: FfiConverterUInt16.read(from: &buf),
                got: FfiConverterUInt16.read(from: &buf)
            )
        case 4: return try .DuplicatePartWrongContent(
                index: FfiConverterUInt16.read(from: &buf)
            )
        case 5: return try .PartWithNoData(
                index: FfiConverterUInt16.read(from: &buf)
            )
        case 6: return try .MissingPart(
                index: FfiConverterUInt16.read(from: &buf)
            )
        case 7: return try .HeaderParseError(
                error: FfiConverterTypeHeaderParseError.read(from: &buf)
            )
        case 8: return try .DecodeError(
                error: FfiConverterTypeDecodeError.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: JoinError, into buf: inout [UInt8]) {
        switch value {
        case .Empty:
            writeInt(&buf, Int32(1))

        case .ConflictingHeaders:
            writeInt(&buf, Int32(2))

        case let .TooManyParts(expected, got):
            writeInt(&buf, Int32(3))
            FfiConverterUInt16.write(expected, into: &buf)
            FfiConverterUInt16.write(got, into: &buf)

        case let .DuplicatePartWrongContent(index):
            writeInt(&buf, Int32(4))
            FfiConverterUInt16.write(index, into: &buf)

        case let .PartWithNoData(index):
            writeInt(&buf, Int32(5))
            FfiConverterUInt16.write(index, into: &buf)

        case let .MissingPart(index):
            writeInt(&buf, Int32(6))
            FfiConverterUInt16.write(index, into: &buf)

        case let .HeaderParseError(error):
            writeInt(&buf, Int32(7))
            FfiConverterTypeHeaderParseError.write(error, into: &buf)

        case let .DecodeError(error):
            writeInt(&buf, Int32(8))
            FfiConverterTypeDecodeError.write(error, into: &buf)
        }
    }
}

extension JoinError: Equatable, Hashable {}

extension JoinError: Error {}

public enum SplitError {
    case Empty
    case CannotFit
    case MaxSplitSizeTooLarge(got: UInt16
    )
    case MinSplitTooSmall
    case InvalidSplitRange
    case InvalidVersionRange
    case EncodeError(error: EncodeError
    )
}

public struct FfiConverterTypeSplitError: FfiConverterRustBuffer {
    typealias SwiftType = SplitError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SplitError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .Empty
        case 2: return .CannotFit
        case 3: return try .MaxSplitSizeTooLarge(
                got: FfiConverterUInt16.read(from: &buf)
            )
        case 4: return .MinSplitTooSmall
        case 5: return .InvalidSplitRange
        case 6: return .InvalidVersionRange
        case 7: return try .EncodeError(
                error: FfiConverterTypeEncodeError.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SplitError, into buf: inout [UInt8]) {
        switch value {
        case .Empty:
            writeInt(&buf, Int32(1))

        case .CannotFit:
            writeInt(&buf, Int32(2))

        case let .MaxSplitSizeTooLarge(got):
            writeInt(&buf, Int32(3))
            FfiConverterUInt16.write(got, into: &buf)

        case .MinSplitTooSmall:
            writeInt(&buf, Int32(4))

        case .InvalidSplitRange:
            writeInt(&buf, Int32(5))

        case .InvalidVersionRange:
            writeInt(&buf, Int32(6))

        case let .EncodeError(error):
            writeInt(&buf, Int32(7))
            FfiConverterTypeEncodeError.write(error, into: &buf)
        }
    }
}

extension SplitError: Equatable, Hashable {}

extension SplitError: Error {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Version {
    case v01
    case v02
    case v03
    case v04
    case v05
    case v06
    case v07
    case v08
    case v09
    case v10
    case v11
    case v12
    case v13
    case v14
    case v15
    case v16
    case v17
    case v18
    case v19
    case v20
    case v21
    case v22
    case v23
    case v24
    case v25
    case v26
    case v27
    case v28
    case v29
    case v30
    case v31
    case v32
    case v33
    case v34
    case v35
    case v36
    case v37
    case v38
    case v39
    case v40
}

public struct FfiConverterTypeVersion: FfiConverterRustBuffer {
    typealias SwiftType = Version

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Version {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .v01

        case 2: return .v02

        case 3: return .v03

        case 4: return .v04

        case 5: return .v05

        case 6: return .v06

        case 7: return .v07

        case 8: return .v08

        case 9: return .v09

        case 10: return .v10

        case 11: return .v11

        case 12: return .v12

        case 13: return .v13

        case 14: return .v14

        case 15: return .v15

        case 16: return .v16

        case 17: return .v17

        case 18: return .v18

        case 19: return .v19

        case 20: return .v20

        case 21: return .v21

        case 22: return .v22

        case 23: return .v23

        case 24: return .v24

        case 25: return .v25

        case 26: return .v26

        case 27: return .v27

        case 28: return .v28

        case 29: return .v29

        case 30: return .v30

        case 31: return .v31

        case 32: return .v32

        case 33: return .v33

        case 34: return .v34

        case 35: return .v35

        case 36: return .v36

        case 37: return .v37

        case 38: return .v38

        case 39: return .v39

        case 40: return .v40

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Version, into buf: inout [UInt8]) {
        switch value {
        case .v01:
            writeInt(&buf, Int32(1))

        case .v02:
            writeInt(&buf, Int32(2))

        case .v03:
            writeInt(&buf, Int32(3))

        case .v04:
            writeInt(&buf, Int32(4))

        case .v05:
            writeInt(&buf, Int32(5))

        case .v06:
            writeInt(&buf, Int32(6))

        case .v07:
            writeInt(&buf, Int32(7))

        case .v08:
            writeInt(&buf, Int32(8))

        case .v09:
            writeInt(&buf, Int32(9))

        case .v10:
            writeInt(&buf, Int32(10))

        case .v11:
            writeInt(&buf, Int32(11))

        case .v12:
            writeInt(&buf, Int32(12))

        case .v13:
            writeInt(&buf, Int32(13))

        case .v14:
            writeInt(&buf, Int32(14))

        case .v15:
            writeInt(&buf, Int32(15))

        case .v16:
            writeInt(&buf, Int32(16))

        case .v17:
            writeInt(&buf, Int32(17))

        case .v18:
            writeInt(&buf, Int32(18))

        case .v19:
            writeInt(&buf, Int32(19))

        case .v20:
            writeInt(&buf, Int32(20))

        case .v21:
            writeInt(&buf, Int32(21))

        case .v22:
            writeInt(&buf, Int32(22))

        case .v23:
            writeInt(&buf, Int32(23))

        case .v24:
            writeInt(&buf, Int32(24))

        case .v25:
            writeInt(&buf, Int32(25))

        case .v26:
            writeInt(&buf, Int32(26))

        case .v27:
            writeInt(&buf, Int32(27))

        case .v28:
            writeInt(&buf, Int32(28))

        case .v29:
            writeInt(&buf, Int32(29))

        case .v30:
            writeInt(&buf, Int32(30))

        case .v31:
            writeInt(&buf, Int32(31))

        case .v32:
            writeInt(&buf, Int32(32))

        case .v33:
            writeInt(&buf, Int32(33))

        case .v34:
            writeInt(&buf, Int32(34))

        case .v35:
            writeInt(&buf, Int32(35))

        case .v36:
            writeInt(&buf, Int32(36))

        case .v37:
            writeInt(&buf, Int32(37))

        case .v38:
            writeInt(&buf, Int32(38))

        case .v39:
            writeInt(&buf, Int32(39))

        case .v40:
            writeInt(&buf, Int32(40))
        }
    }
}

public func FfiConverterTypeVersion_lift(_ buf: RustBuffer) throws -> Version {
    return try FfiConverterTypeVersion.lift(buf)
}

public func FfiConverterTypeVersion_lower(_ value: Version) -> RustBuffer {
    return FfiConverterTypeVersion.lower(value)
}

extension Version: Equatable, Hashable {}

private struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}

// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_bbqrffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if uniffi_bbqrffi_checksum_method_continuousjoiner_add_part() != 37717 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_bbqrffi_checksum_method_joined_data() != 37507 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_bbqrffi_checksum_method_joined_encoding() != 54394 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_bbqrffi_checksum_method_joined_file_type() != 60520 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_bbqrffi_checksum_method_split_encoding() != 23505 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_bbqrffi_checksum_method_split_parts() != 58128 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_bbqrffi_checksum_method_split_version() != 47440 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_bbqrffi_checksum_constructor_continuousjoiner_new() != 24345 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_bbqrffi_checksum_constructor_joined_try_from_parts() != 46929 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_bbqrffi_checksum_constructor_split_try_from_data() != 30552 {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all
